# ğŸ¤– AI Agent Tools RAG Search Engine

![Gradio UI](static/gradio_app.png)

<div align="center">

<!-- Project Status -->

[![Build Status](https://github.com/karenwhite33/agents-tool-rag/actions/workflows/ci.yml/badge.svg)](https://github.com/karenwhite33/agents-tool-rag/actions/workflows/ci.yml)
[![Build Status](https://github.com/karenwhite33/agents-tool-rag/actions/workflows/cd.yml/badge.svg)](https://github.com/karenwhite33/agents-tool-rag/actions/workflows/cd.yml)
![Status](https://img.shields.io/badge/status-active-success.svg)
![GitHub release (latest by date)](https://img.shields.io/github/v/release/karenwhite33/agents-tool-rag)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Python version](https://img.shields.io/badge/python-3.12.8-blue.svg)](https://www.python.org/downloads/)
[![uv](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/astral-sh/uv/main/assets/badge/v0.json)](https://github.com/astral-sh/uv)

<!-- Providers -->

[![Supabase](https://img.shields.io/badge/Supabase-2.18.1-3ECF8E?logo=supabase&logoColor=white)](https://supabase.com/)
[![Qdrant](https://img.shields.io/badge/Qdrant-1.15.1-5A31F4?logo=qdrant&logoColor=white)](https://qdrant.tech/)
[![Cloud Run](https://img.shields.io/badge/Google%20Cloud%20Run-4285F4?logo=googlecloud&logoColor=white)](https://cloud.google.com/run)
[![Prefect](https://img.shields.io/badge/Prefect-3.4.17-FF4300?logo=prefect&logoColor=white)](https://www.prefect.io/)
[![FastAPI](https://img.shields.io/badge/FastAPI-0.116.1-009688?logo=fastapi&logoColor=white)](https://fastapi.tiangolo.com/)
[![Gradio](https://img.shields.io/badge/Gradio-5.45.0-FF4B4B?logo=gradio&logoColor=white)](https://gradio.app/)

</div>

<p align="center">
  <em>A comprehensive RAG-powered search engine for discovering AI agent frameworks, libraries, and tools from RSS feeds, GitHub repositories, and documentation sites</em>
</p>

## ğŸ“š Table of Contents

- [AI Agent Tools Search Engine](#ai-agent-tools-search-engine)
  - [ğŸ“š Table of Contents](#-table-of-contents)
  - [âœ¨ Overview](#-overview)
  - [ğŸ—‚ï¸ Project Structure](#ï¸-project-structure)
  - [âš¡ Quickstart](#-quickstart)
    - [ğŸ› ï¸ Prerequisites](#ï¸-prerequisites)
    - [â¬‡ï¸ Installation](#ï¸-installation)
  - [ğŸ“ Makefile Commands](#-makefile-commands)
  - [âš™ï¸ Settings \& Configuration](#ï¸-settings--configuration)
    - [ğŸ”¢ Embedding Models](#-embedding-models)
  - [ğŸ”Œ Services Providers](#-services-providers)
    - [ğŸ—„ï¸ Supabase](#ï¸-supabase)
    - [ğŸ§  Qdrant](#-qdrant)
    - [âš¡ Prefect](#-prefect)
    - [âš¡ FastAPI](#-fastapi)
      - [Example Queries](#example-queries)
    - [â˜ï¸ Google Cloud Run](#ï¸-google-cloud-run)
    - [ğŸ¨ Gradio UI (Optional)](#-gradio-ui-optional)
    - [ğŸ¤– Opik Integration (Optional)](#-opik-integration-optional)
  - [ğŸ§ª Tests](#-tests)
  - [âœ… Quality Checks](#-quality-checks)
  - [ğŸ“„ License](#-license)

## âœ¨ Overview

This project is a robust Retrieval-Augmented Generation (RAG) system designed to make AI agent tools, frameworks, and libraries easily searchable and accessible. It automates the ingestion of content from RSS feeds, GitHub repositories, and documentation sites. Content is stored in a Supabase PostgreSQL database, while semantic embeddings are generated and indexed in a Qdrant vector database for efficient similarity search.

The data pipeline is orchestrated using Prefect, enabling scheduled, reliable, and reproducible ingestion and embedding workflows. Prefect ensures that new content is regularly fetched, processed, and made available for search without manual intervention.

The backend is powered by a FastAPI application that exposes a set of RESTful endpoints for querying the ingested articles. Users can:

- **Search for articles by unique titles** (fast, keyword-based, no LLM required)
- **Ask natural language questions** about the ingested articles, with answers generated by LLMs in both streaming and non-streaming modes

Multiple LLM providers are supported, including OpenRouter (default, with a generous free tier), OpenAI, and Hugging Face. For OpenAI and Hugging Face, you will need to supply your own API keys.

For user interaction, this repository includes a Gradio-based UI for local exploration and prototyping.

## ğŸ—‚ï¸ Project Structure

```text
â”œâ”€â”€ .github/                                   # GitHub configuration and CI/CD workflows
â”‚   â”œâ”€â”€ workflows/
â”‚   â”‚   â”œâ”€â”€ ci.yml
â”‚   â”‚   â””â”€â”€ cd.yml
â”œâ”€â”€ frontend/                                  # React (Vite) UI â€” main web app
â”‚   â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ package.json
â”‚   â””â”€â”€ ...
â”œâ”€â”€ gradio-frontend/                           # Gradio UI for local testing and demos
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ app.py
â”œâ”€â”€ src/                                       # Main backend source code
â”‚   â”œâ”€â”€ config.py                              # Global configuration loader
â”‚   â”œâ”€â”€ api/                                   # FastAPI application and API logic
â”‚   â”‚   â”œâ”€â”€ exceptions/                        # Custom exception handlers
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â””â”€â”€ exception_handlers.py
â”‚   â”‚   â”œâ”€â”€ main.py                            # FastAPI app entry point
â”‚   â”‚   â”œâ”€â”€ middleware/                        # Middleware (logging)
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â””â”€â”€ logging_middleware.py
â”‚   â”‚   â”œâ”€â”€ models/                            # Pydantic models for API and providers
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ api_models.py
â”‚   â”‚   â”‚   â””â”€â”€ provider_models.py
â”‚   â”‚   â”œâ”€â”€ routes/                            # API route definitions
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ health_routes.py
â”‚   â”‚   â”‚   â””â”€â”€ search_routes.py
â”‚   â”‚   â””â”€â”€ services/                          # Service layer
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ generation_service.py
â”‚   â”‚       â”œâ”€â”€ search_service.py
â”‚   â”‚       â””â”€â”€ providers/                     # LLM and embedding providers
â”‚   â”‚          â”œâ”€â”€ __init__.py
â”‚   â”‚          â”œâ”€â”€ huggingface_service.py
â”‚   â”‚          â”œâ”€â”€ openai_service.py
â”‚   â”‚          â”œâ”€â”€ openrouter_service.py
â”‚   â”‚          â””â”€â”€ utils/                      # Provider utilities
â”‚   â”‚              â”œâ”€â”€ __init__.py
â”‚   â”‚              â”œâ”€â”€ evaluation_metrics.py
â”‚   â”‚              â”œâ”€â”€ messages.py
â”‚   â”‚              â””â”€â”€ prompts.py
â”‚   â”œâ”€â”€ configs/                               # List of RSS/feed configs
â”‚   â”‚   â”œâ”€â”€ feeds_rss.yaml
â”‚   â”œâ”€â”€ infrastructure/                        # Infrastructure integrations
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ qdrant/                            # Qdrant vector DB integration
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ qdrant_vectorstore.py
â”‚   â”‚   â”‚   â”œâ”€â”€ create_collection.py
â”‚   â”‚   â”‚   â”œâ”€â”€ delete_collection.py
â”‚   â”‚   â”‚   â”œâ”€â”€ ingest_from_sql.py
â”‚   â”‚   â”‚   â””â”€â”€ create_indexes.py
â”‚   â”‚   â”œâ”€â”€ supabase/                          # Supabase DB integration
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ create_db.py
â”‚   â”‚   â”‚   â”œâ”€â”€ delete_db.py
â”‚   â”‚   â”‚   â””â”€â”€ init_session.py
â”‚   â”œâ”€â”€ models/                                # Pydantic models for SQLAlchemy and vectorstore
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ article_models.py
â”‚   â”‚   â”œâ”€â”€ sql_models.py
â”‚   â”‚   â””â”€â”€ vectorstore_models.py
â”‚   â”œâ”€â”€ pipelines/                             # Prefect flows and tasks
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ flows/                             # Prefect flow definitions
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ embeddings_ingestion_flow.py
â”‚   â”‚   â”‚   â””â”€â”€ rss_ingestion_flow.py
â”‚   â”‚   â”œâ”€â”€ tasks/                             # Prefect task definitions
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ ingest_embeddings.py
â”‚   â”‚   â”‚   â”œâ”€â”€ fetch_rss.py
â”‚   â”‚   â”‚   â””â”€â”€ ingest_rss.py
â”‚   â””â”€â”€ utils/                                 # Utility functions (logging, text splitting)
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ logger_util.py
â”‚       â””â”€â”€ text_splitter.py
â”œâ”€â”€ tests/                                     # Unit and integration tests
â”‚   â”œâ”€â”€ conftest.py                            # Pytest configuration
â”‚   â”œâ”€â”€ integration/                           # Integration tests (DB, pipeline)
â”‚   â”‚   â”œâ”€â”€ test_db_connection.py
â”‚   â”‚   â””â”€â”€ test_rss_pipeline.py
â”‚   â”œâ”€â”€ test_models/                           # Test table model
â”‚   â”‚   â””â”€â”€ test_sql_models.py
â”‚   â”œâ”€â”€ unit/                                  # Unit tests
â”‚   â”‚   â”œâ”€â”€ test_fastapi.py
â”‚   â”‚   â””â”€â”€ test_fetch_rss_entries.py
â”œâ”€â”€ static/                                    # Static assets (images, etc.)
â”‚   â””â”€â”€ image.png
â”œâ”€â”€ cloudbuild_fastapi.yaml                    # Google Cloud Build config for FastAPI
â”œâ”€â”€ deploy_fastapi.sh                          # Script to deploy FastAPI to Cloud Run
â”œâ”€â”€ Dockerfile                                 # Dockerfile for FastAPI app
â”œâ”€â”€ prefect-cloud.yaml                         # Prefect Cloud deployment config
â”œâ”€â”€ prefect-local.yaml                         # Prefect local deployment config
â”œâ”€â”€ LICENSE                                    # Project license
â”œâ”€â”€ Makefile                                   # Automation commands
â”œâ”€â”€ pyproject.toml                             # Project dependencies
â”œâ”€â”€ README.md                                  # Project Overview
â”œâ”€â”€ INSTRUCTIONS.md                            # Project Installation Instructions
â”œâ”€â”€ requirements.txt                           # Prefect deployment dependencies
â”œâ”€â”€ uv.lock                                    # uv dependency lock file
```

## âš¡ Quickstart

Get started quickly by following these steps. This project is designed to be accessible for both beginners and advanced users.

### ğŸ› ï¸ Prerequisites

Before installation, ensure you have the following tools and accounts set up. These are the minimum requirements for running the pipeline, database, vector store, and LLM provider:

| Requirement                                      | Description           |
| ------------------------------------------------ | --------------------- |
| [Python 3.12](https://www.python.org/downloads/) | Pprogramming language |
| [uv](https://docs.astral.sh/uv/)                 | Packaging tool        |
| [Prefect](https://docs.prefect.io/)              | Flows Orchestrator    |
| [Supabase](https://supabase.com/docs)            | SQL Database          |
| [Qdrant](https://qdrant.tech/)                   | Vector Database       |
| [OpenRouter](https://www.openrouter.com/)        | LLM Provider          |

You do not need the following optional components to run the pipeline unless you plan to use them. The deployment in Google Cloud Run will provide you with an endpoint to serve the app globally. The Gradio UI provides you with a user-friendly interface for interacting with the model, and Opik integration can be used to run evaluations (GEval metric implemented).

| Requirement                                                   | Description                                                 |
| ------------------------------------------------------------- | ----------------------------------------------------------- |
| [Docker](https://docs.docker.com/get-docker/)                 | Containerization platform                                   |
| [Google Cloud SDK](https://cloud.google.com/sdk/docs/install) | Command-line interface for Google Cloud                     |
| [Gradio](https://gradio.app/get_started)                      | UI library                                                  |
| [Opik](https://www.comet.com/site/products/opik/)             | Model evaluation and monitoring (requires `OPENAI_API_Key`) |

### â¬‡ï¸ Installation

Clone the repository, install dependencies, and set up your environment variables:

```bash
git clone https://github.com/karenwhite33/agents-tool-rag.git
cd agents-tool-rag
uv sync --all-groups
source .venv/bin/activate
cp .env.example .env
```

## ğŸ“ Makefile Commands

The Makefile streamlines all common development, deployment, and maintenance tasks. Use it to manage databases, run flows, start services, and check code quality. To see all available commands:

```bash
make help   # Display all available commands
```

```bash
# Supabase
supabase-create                # Create Supabase database
supabase-delete                # Delete Supabase database

# Qdrant
qdrant-create-collection       # Create Qdrant collection
qdrant-delete-collection       # Delete Qdrant collection
qdrant-create-index            # Create Qdrant index
qdrant-ingest-from-sql         # Ingest data from SQL to Qdrant

# Prefect flows
ingest-rss-articles-flow       # Ingest RSS articles flow
ingest-embeddings-flow         # Ingest embeddings flow

# Prefect deployment
deploy-cloud-flows             # Deploy Prefect flows to Prefect Cloud
deploy-local-flows             # Deploy Prefect flows to Prefect Local Server

# Recreate resources
recreate-supabase              # Recreate Supabase resources
recreate-qdrant                # Recreate Qdrant resources
recreate-all                   # Recreate Qdrant and Supabase resources

# Run services
run-api                        # Run FastAPI application
run-gradio                     # Run Gradio application

# Tests
unit-tests                     # Run all unit tests
integration-tests              # Run all integration tests
all-tests                      # Run all tests

# Quality checks
pre-commit-run                 # Run pre-commit hooks
ruff-check                     # Check code lint violations
ruff-check-fix                 # Auto-format code using Ruff
ruff-format                    # Check code format violations
ruff-format-fix                # Auto-format code using Ruff
all-check                      # Run all: linting, formatting and type checking
all-fix                        # Run all fix: auto-formatting and linting fixes
mypy                           # Run MyPy static type checker
clean                          # Clean up cached generated files

# Help
help                           # Display this help message
```

## âš™ï¸ Settings & Configuration

All sensitive credentials, API keys, and model settings are managed via environment variables and configuration files. This allows you to easily switch between providers and models.

Edit the following files to configure your deployment:

- **Project Settings**: `src/config.py`
  - **Necessary**: Qdrant, Supabase, Prefect, OpenRouter
  - **Optional**:
    - From the above optional services listed above Google Cloud Run is configured in the CLI, so no need to set anything here. Gradio does not require any settings and Opik integration requires only the `OPENAI_API_KEY`, which can be set in the `.env` file.
    - See below for details on enabling Jina or Hugging Face embeddings if desired.
- **RSS / Feeds config**: `src/configs/feeds_rss.yaml`

### ğŸ”¢ Embedding Models

The default embedding backend is [Fastembed](https://qdrant.github.io/fastembed/examples/Supported_Models/#supported-text-embedding-models) with the "BAAI/bge-base-en-v1.5" model, providing high-quality English text embeddings. You can easily swap in other supported models by updating the `QDRANT__DENSE_MODEL_NAME` variable in your `.env` file and in `src/config.py`.

The code enables Jina or Hugging Face embeddings. To do so, set `use_jina` or `use_hf` to `True` in the `AsyncQdrantVectorStore` class (`src/infrastructure/vectorstores/qdrant_vectorstore.py`) and provide the necessary API keys and model names in the configuration files. This flexibility allows you to experiment with different embedding providers and optimize for your use case. By setting `True`, the rest of the code does not need to be changed.

```bash
# -------------------------------
# Jina settings (optional)
# -------------------------------
self.jina_settings = settings.jina
self.use_jina = False  # Set to True to enable Jina integration

# -------------------------------
# Hugging Face settings (optional)
# -------------------------------
self.hugging_face_settings = settings.hugging_face

self.hf_client = InferenceClient(
    provider="auto",
    api_key=self.hugging_face_settings.api_key,
)
self.hf_model = self.hugging_face_settings.model
self.use_hf = False  # Set to True to enable HF integration
```

## ğŸ”Œ Services Providers

This project integrates several best-in-class open-source and cloud services to provide a scalable, production-ready RAG pipeline:

| Service  | Description                           | Docs/Links                                                                  |
| -------- | ------------------------------------- | --------------------------------------------------------------------------- |
| Supabase | PostgreSQL database for articles      | [Supabase](https://supabase.com/docs)                                       |
| Qdrant   | Vector DB for embeddings              | [Qdrant](https://qdrant.tech/documentation/database-tutorials/bulk-upload/) |
| Prefect  | Orchestration for ingestion/embedding | [Prefect](https://docs.prefect.io/)                                         |
| FastAPI  | API for querying/search               | [FastAPI](https://fastapi.tiangolo.com/)                                    |
| Gradio   | Optional UI                           | [Gradio](https://gradio.app/get_started)                                    |
| Opik AI  | Optional LLM evaluation               | [Opik](https://opik.ai/)                                                    |
| Google Cloud Run | Deployment and hosting         | [Cloud Run](https://cloud.google.com/run/docs)                                            |

______________________________________________________________________

### ğŸ—„ï¸ Supabase

Supabase acts as the primary relational database, storing all ingested article metadata and content. You must create a Supabase project and update your `.env` file with the connection details. The free tier is sufficient for the current setup (only 10% capacity usage).

```bash
SUPABASE_DB__TABLE_NAME=rss_articles
SUPABASE_DB__HOST=your_supabase_db_host_here
SUPABASE_DB__NAME=postgres
SUPABASE_DB__USER=your_supabase_db_user_here
SUPABASE_DB__PASSWORD=your_supabase_db_password_here
SUPABASE_DB__PORT=6543
```

You should end up with a connection string like this:

```sql
postgresql://[USER]:[PASSWORD]@[HOST]:[PORT]/[NAME]
```

To find the values go to you Supabase project dashboard and click on the "connect" button on the middle of the screen. you shall see the following. If you select the "Transaction Pool" method, you will get the correct host to use.

[![Supabase connection details](static/supabase_string.png)](static/supabase_string.png)

For example:

- user: postgres.apbkobhfnmcqqzqeeqss
- host: aws-1-us-east-2.pooler.supabase.com (take the transaction pool host)
- port: 6543
- name: postgres

Once configured, use the Makefile commands to create or delete the Supabase database schema:

```bash
make supabase-create
make supabase-delete
```

### ğŸ§  Qdrant

Qdrant is a high-performance vector database used to store and search article embeddings. It enables fast, scalable semantic search over your content. The collection created supports dense and sparse vectors and quantization. Payload indexes are created on `feed_author`, `feed_name`, and `title` fields to optimize search queries.

Required settings in your `.env` file:

```bash
QDRANT__API_KEY=your_qdrant_api_key_here
QDRANT__URL=your_qdrant_url_here
```

Use the provided Makefile commands to create/delete, index, and manage your Qdrant collections. The ingestion from SQL command will bulk upload all articles from Supabase to Qdrant without using Prefect.

```bash
make qdrant-create-collection
make qdrant-delete-collection
make qdrant-create-index
make qdrant-ingest-from-sql
```

After bulk uploading data, make sure you run `make qdrant-create-index` to enable HNSW and Optimizers apart from the indexes. These two parameters are disabled during bulk upload for [performance reasons](https://qdrant.tech/documentation/database-tutorials/bulk-upload/).

### âš¡ Prefect

Prefect is used for workflow orchestration, ensuring that data ingestion and embedding generation are reliable and repeatable. Three main flows are provided:

1. **RSS Ingestion Flow**: Fetches the latest articles from RSS feeds and stores them in Supabase.
1. **Qdrant Embeddings Flow**: Generates and stores vector embeddings for all articles, making them searchable via semantic queries.

Required settings in your `.env` file:

```bash
PREFECT__API_KEY=your_prefect_api_key_here
PREFECT__WORKSPACE=your_prefect_workspace_here
PREFECT__API_URL=your_prefect_api_url_here
```

You can run these flows manually or schedule them for automated operation. All flows are defined in the `src/pipelines/flows/` directory and can be deployed to Prefect Cloud or a local Prefect server. Prefect Cloud offers 500 minutes/month on the free tier, so I recommend using it for the final deployment and scheduling and during development use the local server.

Run flows:

```bash
make ingest-rss-articles-flow
make ingest-embeddings-flow
```

The `ingest-embeddings-flow` commands support an optional `FROM_DATE` argument to limit processing to articles published after a specific date (format: `YYYY-MM-DD`).

Run the flow with date arguments:

```bash
make ingest-embeddings-flow FROM_DATE=2023-01-01
```

To deploy flows to Prefect Cloud or your own Prefect server using the prefect yaml configuration, run the following commands. Then you can run the flows from the Prefect UI or CLI:

```bash
make deploy-cloud-flows
make deploy-local-flows
```

Make sure you are logged into Prefect Cloud or your local Prefect server before deploying, and your prefect CLI is configured to use the correct profile.

Cloud:

```bash
prefect cloud login
```

Local:

```bash
prefect server start
prefect worker start --pool '<YOUR_POOL_NAME>' # Start a worker for your local server to execute flows
```

You must create the necessary secrets in Prefect for database and Qdrant access and an authorization token block for GitHub to allow Prefect to clone the repository.

| Service                 | Description                           |
| ----------------------- | ------------------------------------- |
| my-gh-creds             | GitHub Credentials Access Token Block |
| qdrant--api-key         | Qdrant API Key Secret                 |
| qdrant--collection-name | Qdrant Collection Name Secret         |
| qdrant--url             | Qdrant URL Secret                     |
| supabase-db--table-name | Supabase DB Table Name Secret         |
| supabase-db--host       | Supabase DB Host Secret               |
| supabase-db--name       | Supabase DB Name Secret               |
| supabase-db--password   | Supabase DB Password Secret           |
| supabase-db--port       | Supabase DB Port Secret               |
| supabase-db--user       | Supabase DB User Secret               |

If you to to trigger the flows from the CLI instead of the UI, you can use the following commands:

```bash
prefect deploy src/pipelines/flows/rss_ingestion_flow.py:rss_ingest_flow -n rss_ingest_flow

prefect deployment run 'rss_ingest_flow/rss_ingest_flow'
```

```bash
prefect deploy src/pipelines/flows/embeddings_ingestion_flow.py:qdrant_ingest_flow -n qdrant_ingest_flow

prefect deployment run 'qdrant_ingest_flow/qdrant_ingest_flow' --param from_date="2022-01-01"
```

### âš¡ FastAPI

The FastAPI backend exposes a high-performance REST API for searching and querying your AI agent tools corpus. It supports both traditional keyword-based search and advanced LLM-powered question answering. The API is designed for easy integration with custom UIs, automation scripts, or third-party tools.

Supported LLM providers:

- **OpenRouter** (default, free tier available, bring your own API key): It is configured with auto model selection prioritizing latency. Feel free to change it in this file `src/api/models/provider_models.py` if you want to use a specific model.
- **OpenAI** (bring your own API key)
- **Hugging Face** (bring your own API key)

Under `src/api/services/providers` you can find these three model providers. You can easily add more providers by following the existing structure. For all, you need to set the respective API keys in your `.env` file. The rest of the code does not need to be changed.

```bash
OPENROUTER__API_KEY=your_openrouter_api_key_here
OPENAI__API_KEY=your_openai_api_key_here
HUGGING_FACE__API_KEY=your_huggingface_api_key_here
```

To run the FastAPI application locally:

```bash
make run-api
```

API endpoints (see `src/api/main.py` and `src/api/routes/search_routes.py` for details):

| Endpoint                | Description                                      |
| ----------------------- | ------------------------------------------------ |
| `/search/unique-titles` | Retrieve unique article titles (no LLM required) |
| `/search/ask`           | Ask questions (non-streaming, LLM-powered)       |
| `/search/ask/stream`    | Ask questions (streaming, LLM-powered)           |

#### Example Queries

You can test the API endpoints using `curl` commands. Make sure your FastAPI server is running locally on port 8080 (default).

```bash
# Health
curl -X GET "http://127.0.0.1:8080/health" | jq
# Non-streaming
curl -X POST "http://127.0.0.1:8080/search/ask" -H "Content-Type: application/json" -d '{"query_text": "RAG and agentic applications", "limit": 5}' | jq
# Streaming
curl -X POST "http://127.0.0.1:8080/search/ask/stream" -H "Content-Type: application/json" -d '{"query_text": "RAG and agentic applications", "limit": 5}'
# Unique titles
curl -X POST "http://127.0.0.1:8080/search/unique-titles" -H "Content-Type: application/json" -d '{"query_text": "RAG and agentic applications", "limit": 5}' | jq
```

### â˜ï¸ Google Cloud Run

You can deploy the FastAPI backend to Google Cloud Run for scalable, serverless hosting. Use the provided `deploy_fastapi.sh` script, customizing the project ID, service name, and region as needed. The script will build the Docker image using the `cloudbuild_fastapi.yaml` file, push it to Google Container Registry, and deploy it to Cloud Run. Once deployed, your API will be accessible via a public HTTPS endpoint.

```bash
gcloud run services describe <YOUR_SERVICE_NAME> --platform managed --region YOUR_REGION --format "value(status.url)"
```

The endpoint URL can be set in the Gradio UI `.env` file as follows:

```bash
BACKEND_URL=your_fastapi_backend_url_here
```

### ğŸ¨ Frontends

- **React frontend** (`frontend/`): Vite + React app. Run with `cd frontend && npm install && npm run dev` â†’ [http://localhost:5173](http://localhost:5173). Use this for production (e.g. deploy to Vercel).
- **Gradio UI** (`gradio-frontend/`, optional): Simple Gradio UI in `gradio-frontend/app.py` for local testing. Run at [http://localhost:7860](http://localhost:7860) or use:

```bash
make run-gradio
```

![Gradio UI](static/gradio_app.png)

### ğŸ¤– Opik Integration (Optional)

The Opik integration, located in `service/providers/utils/evaluation_metrics.py`, enables automated evaluation of LLM responses using the GEval metric. This is useful for benchmarking and improving the quality of your question-answering system. To enable, set your OpenAI API key in the `.env` file.

```bash
OPIK__API_KEY=your_opik_api_key_here
OPIK__PROJECT_NAME=ai-agent-tools
```

Additionally, in the evaluation script, you must enable the OpenAI Key by commenting out the following line:

```python
settings.openai.api_key = None
```

The integration does not support at the moment Hugging Face. If you want to use it, please use OpenRouter or OpenAI as a provider or check other possibilities in the [Opik integration documentation](https://www.comet.com/docs/opik/tracing/integrations/overview).

## ğŸ§ª Tests

Comprehensive unit and integration tests are provided to ensure the reliability of all components. Integration tests use a dedicated Supabase test database (see `test_models` folder) to avoid interfering with production data. To run tests, use the Makefile commands. Feel free to extend the test suite as you add new features.

```bash
make unit-tests
make integration-tests
make all-tests
```

## âœ… Quality Checks

Code quality is enforced using `pre-commit` hooks, `ruff` for linting and formatting, and `mypy` for static type checking. All quality checks and auto-fixes can be run via the Makefile, ensuring a consistent and maintainable codebase.

Additional checks can be added to the `.pre-commit-config.yaml` file. Current additional checks include:

- `gitleaks` for detecting hardcoded secrets
- `mdformat` for formatting markdown files

## ğŸ“„ License

This project is licensed under the MIT License. See [LICENSE](LICENSE) for details.
